require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { Pool } = require('pg');
const jwt = require('jsonwebtoken');

const app = express();
const PORT = process.env.PORT || 3000;

// Database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

// Test database connection
pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    console.error('‚ùå Database connection error:', err);
  } else {
    console.log('‚úÖ Database connected:', res.rows[0].now);
  }
});

// JWT secret
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-this';

// Middleware
app.use(cors({
  origin: ['https://wizbee-frontend.vercel.app', 'https://wizbee-frontend-*.vercel.app', 'http://localhost:3000', '*'],
  methods: ['GET', 'POST'],
  credentials: false
}));
app.use(express.json());

// ============================================================================
// BITMAP UTILITIES FOR SCORING DATA
// ============================================================================
const ScoringBitmap = {
  // Bit positions for metrics (0-15)
  GUESSES_OFFSET: 0,      // 4 bits: 0-15 guesses
  HINTS_OFFSET: 4,        // 2 bits: 0-3 hints used
  WIN_OFFSET: 6,          // 1 bit: win/loss
  LETTER_SWAPS_OFFSET: 7, // 4 bits: 0-15 swaps
  ERROR_TYPE_OFFSET: 11,  // 5 bits: error pattern flags
  // Bits 16-31 reserved for time in seconds

  encode: (metrics) => {
    let bitmap = 0;
    
    bitmap |= (Math.min(metrics.guesses || 0, 15) & 0xF) << ScoringBitmap.GUESSES_OFFSET;
    bitmap |= (Math.min(metrics.hintsUsed || 0, 3) & 0x3) << ScoringBitmap.HINTS_OFFSET;
    bitmap |= (metrics.won ? 1 : 0) << ScoringBitmap.WIN_OFFSET;
    bitmap |= (Math.min(metrics.letterSwaps || 0, 15) & 0xF) << ScoringBitmap.LETTER_SWAPS_OFFSET;
    
    const errorFlags = ScoringBitmap.encodeErrorTypes(metrics.errorTypes || []);
    bitmap |= (errorFlags & 0x1F) << ScoringBitmap.ERROR_TYPE_OFFSET;
    
    const timeSeconds = Math.min(metrics.timeSeconds || 0, 65535);
    bitmap |= (timeSeconds & 0xFFFF) << 16;
    
    return bitmap;
  },

  decode: (bitmap) => {
    return {
      guesses: (bitmap >> ScoringBitmap.GUESSES_OFFSET) & 0xF,
      hintsUsed: (bitmap >> ScoringBitmap.HINTS_OFFSET) & 0x3,
      won: ((bitmap >> ScoringBitmap.WIN_OFFSET) & 0x1) === 1,
      letterSwaps: (bitmap >> ScoringBitmap.LETTER_SWAPS_OFFSET) & 0xF,
      errorTypes: ScoringBitmap.decodeErrorTypes((bitmap >> ScoringBitmap.ERROR_TYPE_OFFSET) & 0x1F),
      timeSeconds: (bitmap >> 16) & 0xFFFF
    };
  },

  // Error type flags
  ERROR_REVERSAL: 0x01,      // b/d, p/q reversals
  ERROR_SEQUENCE: 0x02,      // letter order issues
  ERROR_PHONETIC: 0x04,      // sound-alike substitutions
  ERROR_VISUAL: 0x08,        // similar-looking letters
  ERROR_REPETITION: 0x10,    // repeated attempts at same mistake

  encodeErrorTypes: (errorArray) => {
    let flags = 0;
    errorArray.forEach(error => {
      if (error === 'reversal') flags |= ScoringBitmap.ERROR_REVERSAL;
      if (error === 'sequence') flags |= ScoringBitmap.ERROR_SEQUENCE;
      if (error === 'phonetic') flags |= ScoringBitmap.ERROR_PHONETIC;
      if (error === 'visual') flags |= ScoringBitmap.ERROR_VISUAL;
      if (error === 'repetition') flags |= ScoringBitmap.ERROR_REPETITION;
    });
    return flags;
  },

  decodeErrorTypes: (flags) => {
    const types = [];
    if (flags & ScoringBitmap.ERROR_REVERSAL) types.push('reversal');
    if (flags & ScoringBitmap.ERROR_SEQUENCE) types.push('sequence');
    if (flags & ScoringBitmap.ERROR_PHONETIC) types.push('phonetic');
    if (flags & ScoringBitmap.ERROR_VISUAL) types.push('visual');
    if (flags & ScoringBitmap.ERROR_REPETITION) types.push('repetition');
    return types;
  }
};

// ============================================================================
// DATABASE HELPER FUNCTIONS
// ============================================================================

// Insert or get theme
async function saveTheme(userEmail, themeText) {
  const result = await pool.query(
    `INSERT INTO themes (user_email, theme_text, created_at)
     VALUES ($1, $2, NOW())
     RETURNING id`,
    [userEmail, themeText]
  );
  return result.rows[0].id;
}

// Insert word if not exists, return word_id
async function saveWord(word) {
  const result = await pool.query(
    `INSERT INTO words (word)
     VALUES ($1)
     ON CONFLICT (word) DO UPDATE SET word = EXCLUDED.word
     RETURNING id`,
    [word.toLowerCase()]
  );
  return result.rows[0].id;
}

// Save word attempt with scoring data
async function saveWordAttempt(themeId, wordId, scoringMetrics) {
  const bitmap = ScoringBitmap.encode(scoringMetrics);
  
  await pool.query(
    `INSERT INTO word_attempts (theme_id, word_id, scoring_data, created_at)
     VALUES ($1, $2, $3, NOW())`,
    [themeId, wordId, bitmap]
  );
}

// Get user's recent words for exclusion (last 50 unique words)
async function getUserRecentWords(userEmail, limit = 50) {
  const result = await pool.query(
    `SELECT DISTINCT w.word
     FROM word_attempts wa
     JOIN themes t ON wa.theme_id = t.id
     JOIN words w ON wa.word_id = w.id
     WHERE t.user_email = $1
     ORDER BY wa.created_at DESC
     LIMIT $2`,
    [userEmail, limit]
  );
  
  return result.rows.map(row => row.word);
}

// ============================================================================
// EXISTING HELPER FUNCTIONS (kept for backward compatibility)
// ============================================================================

// Sanitize user input
function sanitizeTheme(input) {
  if (!input || typeof input !== 'string') {
    return 'random';
  }
  
  const cleaned = input
    .trim()
    .slice(0, 200)
    .replace(/[^a-zA-Z0-9\u00C0-\u017F\s\-',!?]/g, '');
  
  if (cleaned.length === 0) {
    return 'random';
  }
  
  return cleaned;
}

// Middleware to verify JWT token
async function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'Authentication required' });
  }
  
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.userEmail = decoded.email;
    next();
  } catch (error) {
    return res.status(403).json({ error: 'Invalid or expired token' });
  }
}

// Get daily limit from database (for global API limiting only)
async function getDailyLimit() {
  try {
    const result = await pool.query(
      "SELECT value FROM config WHERE key = 'daily_limit'"
    );
    return result.rows[0]?.value || 100;
  } catch (error) {
    console.error('Error getting daily limit:', error);
    return 100;
  }
}

// Get today's API call count
async function getTodayApiCalls() {
  try {
    const today = new Date().toISOString().split('T')[0];
    const result = await pool.query(
      'SELECT api_calls FROM daily_stats WHERE date = $1',
      [today]
    );
    return result.rows[0]?.api_calls || 0;
  } catch (error) {
    console.error('Error getting API calls:', error);
    return 0;
  }
}

// Increment today's API call count
async function incrementApiCalls() {
  try {
    const today = new Date().toISOString().split('T')[0];
    await pool.query(
      `INSERT INTO daily_stats (date, api_calls) VALUES ($1, 1)
       ON CONFLICT (date) DO UPDATE SET api_calls = daily_stats.api_calls + 1`,
      [today]
    );
  } catch (error) {
    console.error('Error incrementing API calls:', error);
  }
}

// Log usage to database
async function logUsage(email, theme, ipAddress) {
  try {
    await pool.query(
      'INSERT INTO usage_logs (ip_address, theme, timestamp) VALUES ($1, $2, NOW())',
      [ipAddress, theme]
    );
  } catch (error) {
    console.error('Error logging usage:', error);
  }
}

// Cache puzzle in database (kept for backward compatibility)
async function cachePuzzle(theme, words, guesses) {
  try {
    await pool.query(
      'INSERT INTO puzzles (theme, word, guesses, created_at) VALUES ($1, $2, $3, NOW())',
      [theme, words.join(','), guesses]
    );
  } catch (error) {
    console.error('Error caching puzzle:', error);
  }
}

// Call Claude API to generate words
async function generateWordWithClaude(theme, excludeWords = []) {
  const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;
  
  if (!CLAUDE_API_KEY) {
    throw new Error('CLAUDE_API_KEY not configured');
  }
  
  const exclusionText = excludeWords.length > 0 
    ? `\n\nIMPORTANT: Do NOT include any of these words the user has seen recently:\n${excludeWords.join(', ')}` 
    : '';
  
  const prompt = `Generate a word for this word puzzle game.

User's theme request: "${theme}"
Random seed: ${Date.now()}-${Math.random()}

Requirements:
- Generate 5-10 words for the theme (varying difficulty, more words for broader themes)
- IMPORTANT: Generate DIFFERENT words each time. Prioritize variety over perfection.
- If generating short words (3-4 letters), maximize diversity in your selection.
${exclusionText}

- Broader themes (e.g., "animals") get more words, specific themes (e.g., "types of sushi") get fewer
- If the input is nonsense, empty, or unclear, choose a fun default theme (animals, food, countries, etc.)
- Pick an appropriate word length (4-10 letters based on difficulty)
- Maximum 12 letters for any word
- Must be a valid word in the same language as the user's request
- If user writes in French, respond with French words. If Spanish, Spanish words, etc
- If user mentions age (e.g., "6 year old"), adjust difficulty accordingly
- If user requests impossible length (18+ letters), choose closest reasonable length
- Use the international code for the language variable: "fr" for French, "es" for Spanish, "de" for German, "it" for Italian, "pt" for Portuguese, "nl" for Dutch, "sv" for Swedish, "pl" for Polish, "fi" for Finnish, etc

Respond with ONLY a JSON object (no markdown, no backticks):
{
  "words": ["R√âUNION", "LIBERT√â", "√âGALIT√â", "FRAN√áAIS", "CH√ÇTEAU", "√âV√âNEMENT", "FR√àRE"],
  "guesses": 8,
  "language": "fr",
  "theme": "French concepts",
  "winMessage": "Vous avez gagn√© !",
  "loseMessage": "Jeu termin√© !",
  "reasoning": "brief explanation"
}`;

  const response = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'x-api-key': CLAUDE_API_KEY,
      'anthropic-version': '2023-06-01',
      'content-type': 'application/json'
    },
    body: JSON.stringify({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 300,
      messages: [{
        role: 'user',
        content: prompt
      }]
    })
  });

  if (!response.ok) {
    throw new Error(`Claude API error: ${response.status}`);
  }

  const data = await response.json();
  const text = data.content[0].text;
  
  const jsonMatch = text.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Invalid response from Claude');
  }
  
  const result = JSON.parse(jsonMatch[0]);

  return {
    words: result.words.map(w => w.toUpperCase()),
    guesses: result.guesses,
    theme: result.theme,
    language: result.language || 'en',
    winMessage: result.winMessage || 'You won!',
    loseMessage: result.loseMessage || 'Game over!',
    reasoning: result.reasoning
  };
}

// ============================================================================
// ENDPOINTS
// ============================================================================

// Google Sign-In endpoint
app.post('/auth/google', async (req, res) => {
  try {
    const { email, googleToken } = req.body;
    
    if (!email) {
      return res.status(400).json({ error: 'Email required' });
    }
    
    // Check if user exists, create if not
    const userCheck = await pool.query(
      'SELECT * FROM users WHERE email = $1',
      [email]
    );
    
    if (userCheck.rows.length === 0) {
      // Create new user with default columns
      await pool.query(
        'INSERT INTO users (email, is_paid, total_themes_used, themes_purchased, created_at) VALUES ($1, $2, $3, $4, NOW())',
        [email, false, 0, 0]
      );
      console.log(`‚úÖ New user created: ${email}`);
    }
    
    // Generate JWT token
    const jwtToken = jwt.sign({ email }, JWT_SECRET, { expiresIn: '30d' });
    
    res.json({
      token: jwtToken,
      email: email,
      isPaid: userCheck.rows[0]?.is_paid || false
    });
    
  } catch (error) {
    console.error('Auth error:', error);
    res.status(500).json({ error: 'Authentication failed' });
  }
});

// Health check
app.get('/', (req, res) => {
  res.json({ 
    status: 'ok',
    service: 'Wizbee API',
    version: '4.0.0 (dyslexia screening + word exclusion)'
  });
});

// Main endpoint: Generate word with exclusion
app.post('/api/generate-word', authenticateToken, async (req, res) => {
  try {
    const { theme } = req.body;
    const userEmail = req.userEmail;
    const ipAddress = req.ip || req.connection.remoteAddress;
    
    const cleanTheme = sanitizeTheme(theme);
    
    // Check global daily API limit
    const dailyLimit = await getDailyLimit();
    const todayApiCalls = await getTodayApiCalls();
    
    if (todayApiCalls >= dailyLimit) {
      console.log(`üö® GLOBAL DAILY LIMIT REACHED! ${todayApiCalls}/${dailyLimit}`);
      return res.status(503).json({
        error: 'Daily limit reached',
        message: 'Service has reached its daily puzzle limit. Please try again tomorrow!',
        upgradeUrl: '/premium'
      });
    }

    // Check user's lifetime theme limit
    const userResult = await pool.query(
      'SELECT total_themes_used, themes_purchased FROM users WHERE email = $1',
      [userEmail]
    );
    
    const totalUsed = userResult.rows[0]?.total_themes_used || 0;
    const themesPurchased = userResult.rows[0]?.themes_purchased || 0;
    const themesAllowed = 4 + themesPurchased;

    if (totalUsed >= themesAllowed) {
      console.log(`‚ö†Ô∏è User ${userEmail} hit theme limit (${totalUsed}/${themesAllowed})`);
      return res.status(429).json({
        error: 'Theme limit reached',
        message: themesPurchased === 0 
          ? 'You\'ve used your 4 free themes. Buy 128 more for $0.99!' 
          : 'Theme limit reached. Purchase more themes to continue!',
        upgradeUrl: '/premium'
      });
    }
    
    // Get user's recent words for exclusion
    const recentWords = await getUserRecentWords(userEmail, 50);
    console.log(`üîç Excluding ${recentWords.length} recent words for ${userEmail}`);
    
    // Generate new words with Claude (with exclusions)
    console.log(`üêù Generating words for theme: ${cleanTheme} (user: ${userEmail}, theme ${totalUsed + 1}/${themesAllowed})`);
    const result = await generateWordWithClaude(cleanTheme, recentWords);
    
    // Save theme to new schema
    const themeId = await saveTheme(userEmail, cleanTheme);
    console.log(`üìù Theme saved with ID: ${themeId}`);
    
    // Save all generated words to words table (for tracking, even if not completed yet)
    await Promise.all(result.words.map(word => saveWord(word)));
    
    // Save to old tables for backward compatibility
    await cachePuzzle(cleanTheme, result.words, result.guesses);
    await incrementApiCalls();
    await logUsage(userEmail, cleanTheme, ipAddress);
    
    // Increment user's lifetime theme counter
    await pool.query(
      'UPDATE users SET total_themes_used = total_themes_used + 1 WHERE email = $1',
      [userEmail]
    );
    
    // Get updated counts
    const updatedUsed = totalUsed + 1;
    const themesRemaining = themesAllowed - updatedUsed;
    
    const updatedApiCount = await getTodayApiCalls();
    console.log(`‚úÖ Puzzle generated | API calls today: ${updatedApiCount}/${dailyLimit} | User: ${userEmail} | Themes: ${updatedUsed}/${themesAllowed}`);
    
    if (updatedApiCount >= dailyLimit * 0.8) {
      console.log(`‚ö†Ô∏è WARNING: Approaching daily API limit! ${updatedApiCount}/${dailyLimit} used`);
    }

    res.json({
      ...result,
      themeId: themeId, // Return themeId for frontend tracking
      themesUsed: updatedUsed,
      themesRemaining: themesRemaining,
      wordsExcluded: recentWords.length
    });
 
  } catch (error) {
    console.error('Error generating word:', error);
    res.status(500).json({
      error: 'Failed to generate word',
      message: 'Please try again',
      fallback: {
        words: ['PUZZLE'],
        guesses: 7,
        theme: 'general',
        language: 'en',
        winMessage: 'You won!',
        loseMessage: 'Game over!'
      }
    });
  }
});

// NEW: Record word attempt endpoint
app.post('/api/record-word-attempt', authenticateToken, async (req, res) => {
  try {
    const { 
      themeId, 
      word, 
      guesses, 
      hintsUsed, 
      won, 
      letterSwaps, 
      errorTypes, 
      timeSeconds 
    } = req.body;

    if (!themeId || !word) {
      return res.status(400).json({ error: 'themeId and word required' });
    }

    // Get or create word_id
    const wordId = await saveWord(word);

    // Save attempt with scoring data
    await saveWordAttempt(themeId, wordId, {
      guesses: guesses || 0,
      hintsUsed: hintsUsed || 0,
      won: won || false,
      letterSwaps: letterSwaps || 0,
      errorTypes: errorTypes || [],
      timeSeconds: timeSeconds || 0
    });

    console.log(`‚úÖ Word attempt recorded: ${word} (theme: ${themeId}, won: ${won})`);
    res.json({ success: true });

  } catch (error) {
    console.error('Error recording word attempt:', error);
    res.status(500).json({ error: 'Failed to record attempt' });
  }
});

// NEW: Analytics endpoint for Showbee
app.get('/api/analytics/:email', authenticateToken, async (req, res) => {
  try {
    const { email } = req.params;
    
    // Only allow users to view their own analytics (or admin check here if needed)
    if (email !== req.userEmail) {
      return res.status(403).json({ error: 'Unauthorized' });
    }

    // Get all attempts with decoded scoring data
    const result = await pool.query(
      `SELECT 
         t.theme_text,
         w.word,
         wa.scoring_data,
         wa.created_at
       FROM word_attempts wa
       JOIN themes t ON wa.theme_id = t.id
       JOIN words w ON wa.word_id = w.id
       WHERE t.user_email = $1
       ORDER BY wa.created_at DESC`,
      [email]
    );

    const attempts = result.rows.map(row => ({
      theme: row.theme_text,
      word: row.word,
      metrics: ScoringBitmap.decode(row.scoring_data),
      timestamp: row.created_at
    }));

    // Calculate aggregate statistics
    const stats = {
      totalAttempts: attempts.length,
      totalThemes: new Set(attempts.map(a => a.theme)).size,
      avgGuesses: attempts.length > 0 ? attempts.reduce((sum, a) => sum + a.metrics.guesses, 0) / attempts.length : 0,
      winRate: attempts.length > 0 ? attempts.filter(a => a.metrics.won).length / attempts.length : 0,
      errorPatterns: {},
      avgTimePerWord: attempts.length > 0 ? attempts.reduce((sum, a) => sum + a.metrics.timeSeconds, 0) / attempts.length : 0
    };

    // Aggregate error types
    attempts.forEach(attempt => {
      attempt.metrics.errorTypes.forEach(errorType => {
        stats.errorPatterns[errorType] = (stats.errorPatterns[errorType] || 0) + 1;
      });
    });

    console.log(`üìä Analytics fetched for ${email}: ${attempts.length} attempts`);
    res.json({ attempts, stats });

  } catch (error) {
    console.error('Error fetching analytics:', error);
    res.status(500).json({ error: 'Failed to fetch analytics' });
  }
});

// Hint endpoint (unchanged)
app.post('/api/get-hint', authenticateToken, async (req, res) => {
  try {
    const { word, theme } = req.body;
    const userEmail = req.userEmail;
    
    if (!word || !theme) {
      return res.status(400).json({ error: 'Word and theme required' });
    }
    
    const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;
    
    if (!CLAUDE_API_KEY) {
      throw new Error('CLAUDE_API_KEY not configured');
    }
    
    const prompt = `You're helping someone solve a word puzzle. The word is "${word}" and the theme is "${theme}".

Give a clever, creative hint that helps them guess the word WITHOUT revealing it directly. The hint should be:
- One sentence only
- Engaging and fun
- Give context clues about the word's meaning or usage
- Don't use the word itself or obvious rhymes
- IMPORTANT: Give the hint in the same language as the word. If the word is French, give the hint in French. If Spanish, give hint in Spanish, etc.

Respond with ONLY the hint text, nothing else.`;

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'x-api-key': CLAUDE_API_KEY,
        'anthropic-version': '2023-06-01',
        'content-type': 'application/json'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 100,
        messages: [{
          role: 'user',
          content: prompt
        }]
      })
    });

    if (!response.ok) {
      throw new Error(`Claude API error: ${response.status}`);
    }

    const data = await response.json();
    const hint = data.content[0].text.trim();
    
    console.log(`üí° Hint generated for ${userEmail}: "${hint}" (word: ${word})`);
    
    res.json({ hint });
    
  } catch (error) {
    console.error('Error generating hint:', error);
    res.status(500).json({
      error: 'Failed to generate hint',
      hint: 'Think about the theme and common words related to it.'
    });
  }
});

// Get stats (unchanged)
app.get('/api/stats', async (req, res) => {
  try {
    const dailyLimit = await getDailyLimit();
    const todayApiCalls = await getTodayApiCalls();
    
    res.json({
      apiCallsToday: todayApiCalls,
      dailyLimit: dailyLimit,
      percentUsed: Math.round((todayApiCalls / dailyLimit) * 100)
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to get stats' });
  }
});

// Start server
app.listen(PORT, () => {
  console.log(`üêù Wizbee backend running on port ${PORT}`);
  console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`Claude API configured: ${!!process.env.CLAUDE_API_KEY}`);
  console.log(`Database configured: ${!!process.env.DATABASE_URL}`);
});
